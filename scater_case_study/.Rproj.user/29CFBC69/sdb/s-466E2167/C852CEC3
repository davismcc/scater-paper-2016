{
    "collab_server" : "",
    "contents" : "---\ntitle: \"SCATER CASE STUDY\"\nauthor: Davis McCarthy & Quin Wills\ndate: \"`r Sys.Date()`\"\noutput: \n    html_document:\n        toc: true\n        toc_float: true\n        theme: united\n        highlight: tango\n        number_sections: false\n        code_folding: hide\n---\n\n\n```{r, echo=F, eval=T, message=F, warning=F}\n\n# setwd( \"~/Dropbox/scater_case_study/\" )\n# setwd( \"~/Google\\ Drive/Manuscripts/scater_paper_nov-2015/scater_case_study/\" )\nlibrary( \"scater\" )\nlibrary( \"EBImage\" )\nlibrary( \"scran\" )\nlibrary( \"RUVSeq\" )\n```\n\n1. **OVERVIEW:** Brief introduction to scater and the case study data.\n2. **GETTING STARTED:** Import data/meta-data,  and run automated QC.\n3. **QC THE CELLS:** Exploratory plots and quality control of the cells.  \n4. **QC THE GENES:** Exploratory plots and quality control of the genes.  \n5. **NORMALISE THE DATA**: Unwanted technical effects in the data, and corrective normalisation.  \n6. **DOWNSTREAM ANALYSIS:** An example of further analysis.\n7. **TECHNICAL STUFF:** Information for bioinformaticians, such as the R session used to run this case study.\n\n---\n\n### 1. OVERVIEW\n\nThis case study is designed to walk you through key scater features from importing and easily QC'ing your single-cell data,  through to seamless integration with other data types and [Bioconductor]( https://www.bioconductor.org/ ) packages. If you're new to single cell RNA-seq,  this case study should help you get started with your own data,  irrespective of the platforms used to process the cells for sequencing. As scater is an [R]( https://www.r-project.org/ ) package,  some of the basic work flow is also implemented as a [shiny]( http://shiny.rstudio.com/ ) GUI for those less familiar with R coding. The aim is to get you from sequencer to higher level analysis and modelling with minimal fuss.  \n\nThe RNA-seq data provided here are 73 cells from two lymphoblast cell lines of two unrelated individuals. Cells were captured,  lysed,  and cDNA generated using a popular [microfluidics platform]( https://www.fluidigm.com/products/c1-system?gclid=CIO41cywp8kCFdgaGwodwYUCHA ). The processing of the two cell lines was replicated across two machines,  with the nuclei of the two cell lines stained with different dyes before mixing on each machine. Cells were imaged before lysis,  with an example image provided together with this data.  \n\nTo run this case study you will require the following packages in addition to scater: [EBImage]( http://bioconductor.org/packages/release/bioc/html/EBImage.html ),  [qvalue]( https://bioconductor.org/packages/release/bioc/html/qvalue.html ),  and [mclust]( https://cran.r-project.org/web/packages/mclust/index.html ).  \n\\  \n\n---\n\n### 2. GETTING STARTED\n\nScater processing can begin with sequencer FASTQ files,  using the inbuilt [Kallisto]( http://nextgenseek.com/2015/05/kallisto-a-new-ultra-fast-rna-seq-quantitation-method/ ) pseudo-aligner. This is dicussed [here](  ) and in the supporting help files. Here we assume that read counts have already been provided from a more traditional RNA-seq pipeline,  and read them in as follows:  \n\\  \n\n```{r, echo=T, eval=T, message=F, warning=F}\n\nreads <- as.matrix( read.csv( \"reads.csv\", row.names = 1 ) )\n\n```\n\\  \n\nIn keeping with best practice in object-oriented bioinformatics, `scater` not only allows you to store your data in a standardised format, but also to associate it with experimental and bioinformatic meta-data. Experimental meta-data are any information associated with individual cells (also called 'samples'), from sequencing metrics to experimental batching and other experimental cell phenotypes. The bioinformatic meta-data are any information related to the genes (also called 'features'). These can be read in,  combined with the sequencing data,  and extracted as shown below. For this example we'll use the automated log-scaled counts per million generated by `scater`,  but see ```calculateTPM()``` as an example function for generating alternative RNA-seq read count formats.  \n\\  \n\nView the first few entris for the cell metadata:\n\n```{r, echo=T, eval=T, message=F, warning=F}\n\ncells <- AnnotatedDataFrame( read.csv( \"cells.csv\", row.names = 1 ) ) # row names match column names in reads\ngenes <- AnnotatedDataFrame( read.csv( \"genes.csv\", row.names = 1 ) ) # row names match row names in reads\nscData <- newSCESet( countData = reads, phenoData = cells, featureData = genes, lowerDetectionLimit = 3 ) \n\npData( scData )[1:3, 1:2] # view some sample meta-data\n```\n\nView the first few entries for the feature metadata:\n\n```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}\nfData( scData )[1:3, 1:2] # view some feature meta-data\n\n```\n\\  \n  \nScater comes with an inbuilt QC function,  which is worth running once all data has been imported as an SCESet object. To do this,  first define any feature (gene) and sample (cell) controls. Here we define ERCC synthetic RNA spike-ins as our feature controls,  with bulk sequencing samples and empty capture sites (i.e. no cells) as blank controls.   \n\\  \n\n```{r, echo=T, eval=T, message=F, warning=F}\n\nspikes <- grepl( \"ERCC-\", row.names( scData ) ) # ERCC spike-ins\nblanks <- scData$sample_type == \"blank (empty site) control\" # negative/background controls\nbulks <- grepl( \"bulk control\", scData$sample_type ) # samples of several hundred cells\nscData <- calculateQCMetrics(\n    scData, feature_controls = list( spikes = spikes ), \n    cell_controls = list( bulks = bulks, blanks = blanks ) )\n\n```\n\\  \n\n---\n\n### 3. QC THE CELLS\n\nA useful first step is flagging/failing poorly performing cells. This can be done from the sample meta-data using the automated QC metrics generated above,  any additional sequencing metrics from sequencing aligner/mapping software,  and additional cell phenotypes such as from imaging. For the sake of demonstration, here we focus on four metrics. Others you may want to consider are % reads mapped to mitochondrial genes,  library PCR duplication rate,  and mean sequencing bias per cell.  \n\\  \n\n```{r, echo=T, eval=T, message=F, warning=F}\n\nscData$use <- (scData$cdna_recovered_in_ng_per_ul > 0.5 & #sufficient cDNA per cell \n                   scData$pct_counts_feature_controls < 1 & # sufficient endogenous RNA\n                   !scData$total_counts < 1e5 & # sufficient reads mapped to features\n                   !scData$filter_on_total_features & # remove cells with unusual numbers of genes\n                   !scData$is_cell_control # controls shouldn't be used in downstream analysis\n)\n\n```\n\\  \n\nBox plots aren't particularly useful for visualising sparse data, so ```plot()``` applied to an SCESet object helps visualise all cells as a cumulative proportion of reads per cell. You can see from the plot below that the two failed cells have curves that look more like the blank controls.  \n\\   \n\n```{r, echo=T, eval=T, message=F, warning=F, fig.width=10, fig.height=6, fig.align=\"center\"}\n\nplot( scData, block1 = \"sample_type\", block2 = \"c1_machine\", colour_by = \"use\",\n      exprs_values = \"counts\")\n\n```\n\\  \n\nScater allows users total flexibility to run their favourite dimension reduction methods,  as decribed [here]() and in the supporting help files. Here we use ```plotPCA()``` to further explore the cells. You can see that the two cell lines cluster separately,  with the respective bulk control samples occuring within the correct clusters. With all single-cell work there is background RNA (secreted or from lysed cells),  with the blanks here clustering between the two samples. One feature to look out for is if individual blanks cluster strongly with one or other cell type,  suggesting that the background admixture isn't homogeneous. As there are more samples here from patient B,  blanks  demonstrate a stronger patient B admixture.  \n\\   \n\n\n```{r, echo=T, eval=T, message=F, warning=F, fig.width=7, fig.height=6, fig.align=\"center\"}\n\nplotPCA( scData, colour_by = \"use\", shape_by = \"sample_type\" )\n\nplotPCA( scData[, grep(\"cell\", scData$sample_type)], colour_by = \"use\", \n         shape_by = \"sample_type\")\n\n```\n\\  \nAnother option available in `scater` is to conduct PCA on a set of QC metrics.\nThe advantage of doing this is that the QC metrics focus on technical aspects of\nthe libraries that are likely to distinguish problematics cells. Automatic \noutlier detection on PCA plots using QC metrics is available to help identify \npotentially problematic cells.\n\nBy default, the following metrics are used for PCA-based outlier detection:\n\n* `pct_counts_top_100_features`\n* `total_features`\n* `pct_counts_feature_controls`\n* `n_detected_feature_controls`\n* `log10_counts_endogenous_features`\n* `log10_counts_feature_controls`\n\nA particular set of variables to be used can be specified with the \n`selected_variables` argument as shown in the example below. \n\n```{r pca-qc-metrics, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=7, fig.height=5, fig.align=\"center\"}\n\n## PCA on the phenoData cannot handle missing values\n## for the exercise here we thus set cdna_recovered_in_ng_per_ul to 100 where \n## there are NA values actually (creating a new dummy variable)\ncdna_temp <- scData$cdna_recovered_in_ng_per_ul\ncdna_temp[is.na(cdna_temp)] <- 100\nscData$cdna_recovered_in_ng_per_ul_no_miss <- cdna_temp\nscData <- plotPCA( scData, size_by = \"use\", shape_by = \"sample_type\", \n                   pca_data_input = \"pdata\", detect_outliers = TRUE,\n                   return_SCESet = TRUE, \n                   selected_variables = c(\"cdna_recovered_in_ng_per_ul_no_miss\",\n                                          \"pct_counts_top_100_features\",\n                                          \"total_features\", \n                                          \"pct_counts_feature_controls\",\n                                          \"n_detected_feature_controls\", \n                                          \"log10_counts_endogenous_features\",\n                                          \"log10_counts_feature_controls\"))\n\nplotReducedDim(scData, colour_by = \"outlier\", shape_by = \"use\", ncomponents = 3)\n\nplotReducedDim(scData[, grep(\"cell\", scData$sample_type)], \n               colour_by = \"outlier\", shape_by = \"use\", ncomponents = 3)\n\nplotPCA( scData[, grep(\"cell\", scData$sample_type)], colour_by = \"outlier\", \n         shape_by = \"use\", pca_data_input = \"pdata\")\nplotDiffusionMap( scData[, grep(\"cell\", scData$sample_type)], \n                  colour_by = \"outlier\", shape_by = \"use\", \n                  pca_data_input = \"pdata\")\n```\n\nHaving detected potential outliers on the phenotype data (i.e. cell metrics) we\ncan see where these cells appear on PCA and diffusion map plots based on the \nexpression data.\n\n```{r pca-difmap-outliers, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=10, fig.height=5, fig.align=\"center\"}\nplotPCA( scData[, grep(\"cell\", scData$sample_type)], ncomponents = 3,\n         shape_by = \"use\", pca_data_input = \"pdata\", colour_by = \"outlier\")\n\np1 <- plotPCA( scData, colour_by = \"use\", shape_by = \"sample_type\", \n         size_by = \"outlier\" ) + ggtitle(\"PCA\")\np2 <- plotDiffusionMap( scData, colour_by = \"use\", shape_by = \"sample_type\", \n         size_by = \"outlier\" ) + ggtitle(\"Diffusion map\")\nmultiplot(p1, p2, cols = 2)\n```\n\nWith `scater`, any specific set of features based on prior knowledge can be used for PCA, t-SNE or diffusion maps. A feature set to use can be defined by supplying the `feature_set` argument to `plotPCA`, `plotTSNE` or `plotDiffusionMap`. This allows, for example, using only housekeeping features or control features or cell cycle genes to produce reduced-dimension plots. The plots below use only the spike-in genes defined as such earlier.\n\n```{r pca-difmap-ercc-genes, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=10, fig.height=5, fig.align=\"center\"}\np1 <- plotPCA( scData, feature_set = fData(scData)$is_feature_control, \n               colour_by = \"use\", shape_by = \"sample_type\", \n               size_by = \"outlier\" ) + ggtitle(\"PCA\")\np2 <- plotDiffusionMap( scData, feature_set = fData(scData)$is_feature_control, \n                        colour_by = \"use\", shape_by = \"sample_type\", \n                        size_by = \"outlier\" ) + ggtitle(\"Diffusion map\")\nmultiplot(p1, p2, cols = 2)\n```\n\nThe following plot uses only the genes annotated as cell cycle genes (this annotation was included in the genes information loaded into the SCESet object at the start). Points are coloured by expression of RAN (ENSG00000132341), a gene associated with the G2/M phase of the cell cycle.\n\n```{r pca-diffmap-ccn-genes, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=10, fig.height=5, fig.align=\"center\"}\ncell_cycle_genes <- !is.na(fData(scData)$cell_cycle_phase)\nsum(cell_cycle_genes)\nmost_exprs_ccycle <- which(cell_cycle_genes & \n                               fData(scData)$total_feature_counts > 100000)\nknitr::kable(fData(scData)[most_exprs_ccycle,] )\np1 <- plotPCA(scData, feature_set = cell_cycle_genes, \n               colour_by = featureNames(scData)[most_exprs_ccycle[8]], \n               shape_by = \"sample_type\", \n               size_by = \"use\" ) + ggtitle(\"PCA\")\np2 <- plotDiffusionMap( scData, feature_set = cell_cycle_genes, \n                        colour_by = featureNames(scData)[most_exprs_ccycle[8]], \n                        shape_by = \"sample_type\", \n                        size_by = \"use\" ) + ggtitle(\"Diffusion map\")\nmultiplot(p1, p2, cols = 2)\n\n```\n\n```plotPhenoData()``` can be used to explore specific sample meta-data values. For example,  in the plot below we can see strong association between cDNA recovery and number of genes detected in a cell. The two failed cells demonstrate low gene coverage (total features) and cDNA recovery. \n\n\\  \n\n```{r, echo=T, eval=T, message=F, warning=F, fig.width=6, fig.height=4.5, fig.align=\"center\"}\n\nplotPhenoData( scData, aesth = aes_string( x = \"cdna_recovered_in_ng_per_ul\", \n                                         y = \"total_features\", colour = \"use\" ) )\n\n```\n\\  \n\nOne element of QC that can prove challenging to judge from the above criteria is if more than one cell ( or cell debris from other cells ) are being sequenced. With most cell processing platforms a small percentage of cells won't be truly single. One solution is imaging individual cells,  which also allows for the incorporation of fluorescence phenotypes such as viability and nuclear content ( for cell cycle analysis ). Using the [EBImage]( http://bioconductor.org/packages/release/bioc/html/EBImage.html ) package,  an example image of a stained cell is processed and displayed below,  with results incorporated into the sample meta-data.  \n\\  \n\n```{r, echo=T, eval=T, fig.width=4, fig.height=4, fig.align=\"center\"}\n\nimageQC <- function(cell) { \n    require( \"EBImage\" )\n    pass <- TRUE # if the cell should be passed or failed\n    \n    im <- readImage( paste( cell, \".tif\", sep = \"\" ) ) # read in image TIFF for cell of interest\n    im <- thresh( im, w = 20, h = 20, offset = 0.1 ) # convert to binary fluorescence matrix \n    display( im, method = \"raster\" ) # view fluorescent spot(s)\n    im <- bwlabel(  opening(  im,  makeBrush( 3, \"gaussian\" ) ) ) # label clusters of glowing spots\n    \n    cl <- sort( table( im )[-1], decreasing = TRUE ) # pixels per fluorescent spot\n    if ( sum( cl > 1e2 ) != 1 ) pass <- FALSE # pass if a single spot greater than 100 pixels \n    \n    sh <- prcomp( which( im == names( cl )[1],  arr.ind = TRUE ) )  # a non-circular shape may be a doublet/dividing cell\n    if ( sh$sdev[1] ^ 2/sum( sh$sdev ^ 2 ) > 0.75 ) pass <- FALSE\n    \n    pass\n}\n\npData( scData )[\"cellB_1_04\", \"use\"] <- \n    (pData( scData )[\"cellB_1_04\", \"use\"] & imageQC( \"cellB_1_04\" ) )\n\n```\n\\ \n\n\n---\n\n### 4. QC THE GENES\n\nScater allows you to set minimum QC thresholds for a gene to be considered sufficiently expressed in your downstream analysis. Here,  using the inbuilt  ```is_exprs()``` function,  we enforce that a gene must have least three reads in at least three cells in both replicates.  \n\\  \n\n```{r, echo=TRUE, eval=TRUE, }\nreps <- scData$c1_machine # the machine replicates\nis_exprs(scData) <- counts(scData) >= 3\nexprsThresh <- sapply( 1:2,  \n               function(r) apply( is_exprs( scData )[, scData$use & reps == r], 1, \n                                    function(x) sum( x ) >= 3 ) )\nfData( scData )$use <- (apply( exprsThresh, 1, all ) & # endogenous genes above the threshold are used downstream\n                            !fData( scData )$is_feature_control_spikes)\n\n```\n\\  \n\nIt can be useful to plot gene expression frequency versus mean expression level\nto assess the effects of technical dropout in the dataset. We fit a non-linear\nleast squares curve for the relationship between expression frequency and mean\nexpression and use this to define the number of genes above high technical \ndropout and the numbers of genes that are expressed (here defined as at least 4\ncounts) in at least 50% and at least 25% of cells. A subset of genes to be \ntreated as feature controls can be specified, otherwise any feature controls \npreviously defined are used.\n\\  \n\n```{r, echo=TRUE, eval=TRUE, fig.width=7, fig.height=5, fig.align=\"center\"}\nplotQC(scData, type = \"exprs\") \n```\n\\  \n\nIt can also be useful to look at total expression levels acrsoo gene biotypes. \nThe plot below shows the distributions of log-10 scale total gene counts for \ngenes of different annotated biotypes. The biotypes are ordered by median total\ncounts, and the jittered points beneath the violin plots indiciate the number of \ngenes in the biotype. We want to see many protein-coding genes with reasonably \nhigh expression. This is exactly what we see here, with protein-coding genes \nappearing as the biotype with second-highest median expression behind the very \nsmall (but highly expressed) category of Mt_rRNA genes.\n\\\n\n```{r, echo=T, eval=T, message=F, warning=F, fig.width=8, fig.height=6, fig.align=\"center\"}\noo <- order(unlist(dplyr::summarise(dplyr::group_by(fData(scData), gene_biotype),\n                 median(log10_total_feature_counts))[,2]), decreasing = TRUE)\nfData(scData)$biotype <- factor(fData(scData)$gene_biotype, \n                                levels = levels(fData(scData)$gene_biotype)[oo])\n\nplotFeatureData(scData, aes(x = biotype, y = log10_total_feature_counts),\n                theme_size = 6) +\n    theme(axis.text.x = element_text(angle = 90, hjust = 0, vjust = 0.5))\n\n```\n\\ \n\nThe ```plotQC()``` function provides several useful  QC plots,  such as the example below that considers the the number of reads consumed by the top 50 expressed genes. Aside from spike-ins, these are typically mitochondrial and housekeeping genes. Here,  as with most single-cell experiments,  a large proportion of reads are being are taken up by uninteresting biology.  \n\nTo make gene labels more interpretable we append the gene symbol to the Ensembl\ngene IDs.\n\n\n```{r append-gene-symbols}\nfeatureNames(scData) <- paste(fData(scData)$hgnc_symbol, featureNames(scData),\n                              sep = \"_\")\n```\n\n\n```{r, echo=T, eval=T, message=F, warning=F, fig.width=6, fig.height=6, fig.align=\"center\"}\nplotQC( scData[fData( scData )$use, pData( scData )$use], \n        type = \"highest-expression\", \n        col_by_variable = \"sample_type\" )\n```\n\n\n---\n\n### 5. NORMALISE THE DATA\n\nOnce you have filtered cells and genes,  a next step is to explore technical drivers of variability in the data to inform data normalisation before downstream analysis. \n\nExperimental design is a critical, but neglected, aspect of \\gls{scrnaseq} studies. To the best of my knowledge, methods like those described in this section for exploring experimental and QC variables and the experimental design, do not feature in any scRNA-seq software packages apart from `scater`. There are a very large number of potential confounders, artifacts and biases in \\gls{scrnaseq} studies. Exploring the effects of such explanatory variables (both those recorded during the experiment and computed QC metrics) is crucial for appropriate modeling of the data. The \\scater\\ package provides a set of methods specifically for quality control of experimental and explanatory variables, which will be demonstrated briefly here.\n\nUsing the ```plotPCA()``` function we can see that principal component one is driven by differences between the two machine replicates,  which in turn is due to differences in gene coverage. Differences in number of detected genes is a common driver of cell clustering  and can be result of biology (e.g. different cell types, cell cycle). However, it often has a strong technical component due to variably recovered RNA,  reverse transcription,  or library amplification. Its effect can also be notably non-linear,  affecting low expressed and high expressed genes differently. The ```plotQC()``` function can be used to explore the the marginal % variance explained (per gene) of the various technical factors. In the second plot we can see that it's not unusual for gene coverage to explain more than 10% of the expression variance of a gene.  \n\\  \n\n```{r pca-diffmap-normalisation, echo=T, eval=T, message=F, warning=F, fig.width=7, fig.height=5, fig.align=\"center\"}\nplotPCA( scData[fData( scData )$use, scData$use],  # only plot genes and cells of interest\n         colour_by = \"sample_type\", \n         shape_by = \"c1_machine\", \n         size_by = \"total_features\" )\n\nplotDiffusionMap( scData[fData( scData )$use, scData$use], ntop = 5000,\n                  colour_by = \"sample_type\", \n                  shape_by = \"c1_machine\", \n                  size_by = \"total_features\" )\n```\n\nThe relative importance of different explanatory variables can be explored with some of the `plotQC` function options. Supplying the `type = \"expl\"` argument to `plotQC` computes the marginal $R^2$ for each variable in the \\textsf{SCESet} when fitting a linear model regressing expression values for each gene against just that variable, and displays a density plot of the gene-wise marginal $R^2$ values for the variables. The default approach looks at all variables in the \\textsf{phenoData} slot of the object and plots the top `nvars_to_plot` variables (default is 10). \n\nAlternatively, one can choose a subset of variables to plot in this manner, which we do here. The density curves for marginal $R^2$ show the relative importance of different variables for explaining variance in expression between cells. \n\n```{r plotqc-expl-vars, echo=T, eval=T, message=F, warning=F, fig.width=8, fig.height=4.5, fig.align=\"center\"}\nplotQC( scData[fData( scData )$use, scData$use], \n        type = \"explanatory-variables\", \n        variables = c(\"pct_counts_top_100_features\", \"total_features\", \n                      \"pct_counts_feature_controls\", \"c1_machine\",\n                      \"n_detected_feature_controls\", \n                      \"log10_counts_endogenous_features\",\n                      \"log10_counts_feature_controls\", \"sample_type\") )\n```\n\n\nThis analysis indicates that total number of features detected and the sequencing depth (number of counts) for endogenous genes, in particular, have substantial\nexplanatory power for many genes, so these variables are good candidates for\nconditioning out in a normalisation step, or including in downstream statistical\nmodels. The number of detected feature controls (spike-in genes) does not appear to be an important explanatory variable.\n\nOne can also easily produce plots to identify principal components that correlate with experimental and QC variables of interest. The function `plotQC` with the option `type = \"find-pcs\"` ranks the principal components in decreasing order of $R^2$ from a linear model regressing PC value against the variable of interest. The default behaviour is to show the relationships between the variable of interest and the six principal components with the strongest relationship to the variable (as measured by $R^2$). This works both for continous and categorical variables. This type of plot  can indicate which explanatory variables may be driving differences between cells as detected by PCA and highlight which PCs are associated with the variable. The \"total features\" variable shows very strong correlation with both principal components 1 and 2.\n\n```{r, echo=T, eval=T, message=F, warning=F, fig.width=10, fig.height=6, fig.align=\"center\", message=FALSE, results='hide'}\np1 <- plotQC( scData[fData( scData )$use, scData$use], \n        type = \"find-pcs\", variable = \"total_features\" )\np2 <- plotQC( scData[fData( scData )$use, scData$use], \n        type = \"find-pcs\", variable = \"sample_type\" )\nmultiplot(p1, p2, cols = 2)\n```\n\nThe cells in this dataset were processed on two C1 machines, which gives rise to a substantial batch effect. The QC plots below show that the C1 machine factor is correlated with the first principal component. This effect is likely caused by the difference in amount of cDNA recovered per cell, which is even more strongly correlated with the first principal component. Thus, differences in batches are a major source of variation between the cells.\n\n```{r plot-qc-pcs-c1-machine}\nscData$c1_machine <- as.factor(scData$c1_machine)\np1 <- plotQC( scData[fData( scData )$use, scData$use], \n        type = \"find-pcs\", variable = \"c1_machine\" )\np2 <- plotQC( scData[fData( scData )$use, scData$use], \n        type = \"find-pcs\", variable = \"cdna_recovered_in_ng_per_ul\")\nmultiplot(p1, p2, cols = 2)\n```\n\nThe `plotQC()` function can also be used to produce a pairs plot of explanatory variables (with the same calls as above, but with `method = \"pairs\"`). The plot below shows this use case for looking at the % counts from the top 100 most-expressed genes, the total number of expressed genes, the % of counts from feature controls, the number of detected feature controls, the  number of counts (on the log-10 scale) from endogenous features, the number of counts (log-10 scale) from feature controls and sample type. The explanatory variables are ordered by the median $R^2$ of the variable across all genes, and this value is reported on the plot. This type of plot is useful for finding correlations between experimental and QC variables with substantial explanatory power.\n\n```{r, echo=T, eval=T, message=F, warning=F, fig.width=8, fig.height=8, fig.align=\"center\"}\nplotQC( scData[fData( scData )$use, scData$use], \n        type = \"expl\", method = \"pairs\", \n        variables = c(\"pct_counts_top_100_features\", \"total_features\", \n                      \"pct_counts_feature_controls\", \"c1_machine\",\n                      \"n_detected_feature_controls\", \n                      \"log10_counts_endogenous_features\",\n                      \"log10_counts_feature_controls\", \"sample_type\"),\n        theme_size = 6)\n\n```\n\\  \n\nAfter important explanatory variables have been identified with the tools shown above, their effects can be accounted for in subsequent statistical models, or they can be conditioned out using `normaliseExprs()`, if so desired. If a design matrix incorporating a selection of explanatory variables is supplied as an argument to `normaliseExprs`, then normalised expression values returned for each feature will be the residuals from a linear model fitted with the design matrix, after any size-factor normalisation has been applied to the expression data. \n\nNormalising single-cell RNA-seq data is a topic in its infancy, but many of the basic principles still apply. How much you choose to initially correct for technical factors depends on your question of interest and the ease with which they can be accounted for in downstream models.\n\\  \n\nIn `scater` it is easy to perform size-factor normalisation using the \"TMM\" approach (the default in the [edgeR]() package), the \"RLE\" approach (default in the [DESeq]() package), an \"upper-quartile approach\" (as proposed by Bullard et al (2010)) or simple scaling by total counts. Size-factor normalisation can be carried out on a subsetted SCESet object, normalising either to ERCC spike-in genes or to endogenous genes if desired. Under certain circumstances either may be appropriate. Careful thought should be given to applying scale-factor normalisation as underlying assumptions from methods developed for bulk RNA-seq may not be appropriate for all single-cell datasets.\n\nHowever, [Lun et al (2016)](http://genomebiology.biomedcentral.com/articles/10.1186/s13059-016-0947-7) recently published a size-factor normalisation method specifically designed\nfor scRNA-seq data. This method performs much better on single-cell data and its\nimplementation in the Bioconductor package `scran` allows seamless integration \ninto the `scater` workflow. (The `scran` package itself depends on `scater`).\n\nWe recommend using the `scran` size-factor normalisation approach and \ndemonstrate its use here.\n\nIn the code below we use the `filter` function to select a subset of cells from\nan `SCESet` object (this method works just as the `filter` function in the \n`dplyr` package on which it is based).\n\n```{r pca-norm-plots, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.align=\"center\", fig.width=10, fig.height=5.5}\n## subset to form a QC's version of the data\nscDataQC <- filter(scData, use)\nscDataQC <- scDataQC[fData(scData)$use | fData(scData)$is_feature_control,]\nercc_genes <- fData(scDataQC)$is_feature_control\nendog_genes <- !ercc_genes\n\n## size factor normalisation with scran \nqclust <- quickCluster(scDataQC, min.size = 20)\nscDataQC <- computeSumFactors(scDataQC, sizes = 10, clusters = qclust)\nsummary(scDataQC$size_factor)\nscDataQC <- normalise(scDataQC)\n\nscDataQC_spikenorm <- computeSumFactors(scDataQC, sizes = 10, \n                              get.spikes = TRUE)\nsummary(scDataQC_spikenorm$size_factor)\nscDataQC_spikenorm <- normalise(scDataQC_spikenorm)\n\nset_exprs(scDataQC, \"ercc_norm_exprs\") <- exprs(scDataQC_spikenorm)\nset_exprs(scDataQC, \"endog_norm_exprs\") <- exprs(scDataQC)\n## subset again so that only endogenous genes are used\nscDataQC <- scDataQC[fData(scDataQC)$use,]\nplt_pca_ercc_norm <- plotPCA(\n    scDataQC, exprs_values = \"ercc_norm_exprs\", size_by = \"total_features\",  \n    colour_by = \"sample_type\", shape_by = \"c1_machine\") + \n    ggtitle(\"PCA - ERCC size-factor normalisation\") + \n    theme(legend.position = \"bottom\")\nplt_pca_endog_norm <- plotPCA(\n    scDataQC, exprs_values = \"endog_norm_exprs\", size_by = \"total_features\",  \n    colour_by = \"sample_type\", shape_by = \"c1_machine\") + \n    ggtitle(\"PCA - endogenous size-factor normalisation\") + \n    theme(legend.position = \"bottom\")\nmultiplot(plt_pca_ercc_norm, plt_pca_endog_norm, cols = 2)\n```\n\nIn the PCA plots above we see that the first principal component seems to separate cells based on the C1 machine used to process them, even after appropriate size-factor normalisation. The `plotQC` function confirms this in the plot below: principal component 1 is the PC most highly correlated with C1 machine. \n\n```{r  pca-norm-plot-find-pcs, echo=FALSE, eval=TRUE, message=FALSE, warning=FALSE, fig.align=\"center\", fig.width=6, fig.height=6}\nscDataQC$c1_machine <- as.factor(scDataQC$c1_machine)\nplotQC( scDataQC, type = \"find-pcs\", variable = \"c1_machine\")\n```\n\nWe would prefer such technical effects to be removed by normalisation, so below we demonstrate a further alternative approach. We see how \"customised\" normalisation approaches can be easily incorporated into the `scater` workflow.\n\nIn this example we normalise and standardise counts conditioned on expression level, showing the PCA for the corrected data. One advantage of this approach is that a biologically 'noisy' gene is naturally defined as one with greater dispersion than other genes at a similar expression level. In the normalised data these are genes with a mean absolute deviation greater than 1. \n\n```{r custom-norm-exprs, echo=T, eval=T, message=F, warning=F, fig.width=8, fig.height=6, fig.align=\"center\"}\n\nrp <- scData$c1_machine[scData$use] # replicates\nmn <- sapply( 1:2,  # mean log expression per replicate\n              function(r) rowMeans(exprs( scData )[fData( scData )$use, \n                                                   scData$use][, rp == r])) \n\nexprsNorm <- counts( scData )[fData( scData )$use, pData( scData )$use] # read counts to normalise\nwn <- floor( 0.05*nrow( scData ) ) # consider a sliding window of 10% of genes\nfor (r in 1:2) { # normalise per replicate\n  exprsNorm[, rp == r] <- t( sapply( row.names( exprsNorm ), function(g){\n    nh <- head( sort( abs( mn[, r] - mn[g, r] ) ), wn ) # neighbourhood of similarly expressing genes\n    nh <- exprsNorm[names( nh ), rp == r]\n    nh <- log2( t( t( nh ) / colSums( nh ) ) * 1e5 + 1 ) # locally normalise\n    nh <- nh - mean( nh ) # locally standardise \n    nh <- nh / mean( abs( nh ) )\n    nh[1, ]\n  } ) )  \n}\n\n### add normalised expression values to SCESet object and make PCA plot\nnorm_exprs(scDataQC) <- exprsNorm\nplt_cond_norm <- plotPCA(\n    scDataQC, exprs_values = \"norm_exprs\", shape_by = \"c1_machine\", \n        colour_by = \"sample_type\", size_by = \"total_features\", \n        scale_features = FALSE) + \n    ggtitle(\"PCA - expression conditional normalisation\") + \n    theme(legend.position = \"bottom\")\nplt_cond_norm\n```\n\\    \n\nAfter this normalisation procedure we see that the first principal component now separates cells from the two patients and neither the first nor second principal component appears influenced by the C1 machine used to process the cells. \n\nFurthermore, C1 machine shows no correlation with the top principal components, \nas shown in the plot below.\n\n```{r  pca-norm-plot-find-pcs-2, echo=FALSE, eval=TRUE, message=FALSE, warning=FALSE, fig.align=\"center\", fig.width=5, fig.height=4}\nplotQC( scDataQC, type = \"find-pcs\", variable = \"c1_machine\", \n        exprs_values = \"norm_exprs\")\n```\n\nAnother option is to regress out effects of technical factors in the \nnormalisation step.\n\n```{r regress-factors-norm,  echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.align=\"center\", fig.width=6, fig.height=9}\ndesign <- model.matrix(~scDataQC$log10_counts_endogenous_features +\n                           scDataQC$pct_counts_top_100_features +\n                           scDataQC$pct_counts_feature_controls +\n                           scDataQC$c1_machine)\nset_exprs(scDataQC, \"norm_exprs_resid\") <- norm_exprs(\n    normaliseExprs(scDataQC, design = design,\n                   method = \"none\", exprs_values = \"exprs\",\n                   return_norm_as_exprs = FALSE) )\n\nplt_sf_norm_resid <- plotPCA(\n    scDataQC, exprs_values = \"norm_exprs_resid\", shape_by = \"c1_machine\", \n        colour_by = \"sample_type\", size_by = \"total_features\", \n        scale_features = TRUE) + \n    ggtitle(\"PCA - size-factor normalisation residuals\") + \n    theme(legend.position = \"bottom\")\nplt_sf_norm_resid\n```\n\nAs we see here, this simple regression approach is here also able to \nsubstantially remove the C1 machine effect from that the data so that the first\nprincipal component now separates cells by patient.\n\nWe can also check the results that would be obtained when regressing out \ntechnical effects computed from the expression values but *not* C1 machine. This\ncan give us an idea of what effects could be removed if we did not know that \ncells were process on different C1 machines and only had access to the QC metrics\nwe could compute from the expression data, or other sample metadata information\nprovided.\n\nThe PCA plots below show  the results after regressing out log10(counts) \nfrom endogenous features, % counts from the top 100 most-expressed features, \nthe percentage counts from control features and the log10(counts) from feature\ncontrols (top) and after regressing out all of those effects plus cDNA recovered\nfrom each cell in ng per microlitre.\n\n\n```{r  regress-factors-norm-2,  echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.align=\"center\", fig.width=6, fig.height=9}\ndesign2 <- model.matrix(~scDataQC$log10_counts_endogenous_features +\n                            scDataQC$pct_counts_top_100_features +\n                            scDataQC$pct_counts_feature_controls +\n                            scDataQC$log10_counts_feature_controls)\nset_exprs(scDataQC, \"norm_exprs_resid2\") <- norm_exprs(\n    normaliseExprs(scDataQC, design = design2,\n                   method = \"none\", exprs_values = \"exprs\",\n                   return_norm_as_exprs = FALSE) )\n\nplt_cond_norm_resid2 <- plotPCA(\n    scDataQC, exprs_values = \"norm_exprs_resid2\", shape_by = \"c1_machine\", \n        colour_by = \"sample_type\", size_by = \"total_features\", \n        scale_features = FALSE) + \n    ggtitle(\"PCA - size-factor normalisation residuals technical factors\") + \n    theme(legend.position = \"bottom\")\n\ndesign3 <- model.matrix(~scDataQC$log10_counts_endogenous_features +\n                            scDataQC$pct_counts_top_100_features +\n                            scDataQC$pct_counts_feature_controls +\n                            scDataQC$log10_counts_feature_controls +\n                            scDataQC$cdna_recovered_in_ng_per_ul_no_miss)\nset_exprs(scDataQC, \"norm_exprs_resid3\") <- norm_exprs(\n    normaliseExprs(scDataQC, design = design3,\n                   method = \"none\", exprs_values = \"exprs\",\n                   return_norm_as_exprs = FALSE) )\n\nplt_cond_norm_resid3 <- plotPCA(\n    scDataQC, exprs_values = \"norm_exprs_resid3\", shape_by = \"c1_machine\", \n        colour_by = \"sample_type\", size_by = \"total_features\", \n        scale_features = FALSE) + \n    ggtitle(\"PCA - size-factor normalisation residuals incl cDNA\") + \n    theme(legend.position = \"bottom\")\n\nmultiplot(plt_cond_norm_resid2, plt_cond_norm_resid3)\n```\n\nHere, regressing out only the technical QC metrics does not remove the major \neffect of C1 machine, but regressing out cDNA concentration as well does (so \nthe first principal component now separates the two patients). Thus, for \nremoving known effects, the regression approach implemented in `scater` is \neffective, but more needs to be done to find _hidden_ effects such as unknown\nbatch effects, or similar.\n\nLook at the performance of `removeBatch` from the `limma` package:\n\n```{r limma-remove-batch, echo=TRUE, eval=TRUE}\ndesign_rbe <- model.matrix(~as.character(scDataQC$sample_type))\nrbe_norm_exprs <- removeBatchEffect(exprs(scDataQC), batch = scDataQC$c1_machine,\n                                    design = design_rbe)\nrbe_norm_exprs <- removeBatchEffect(get_exprs(scDataQC, \"endog_norm_exprs\"), \n                                    batch = scDataQC$c1_machine,\n                                    design = design_rbe)\nset_exprs(scDataQC, \"norm_exprs_rbe\") <- rbe_norm_exprs\nplt_rbe_norm <- plotPCA(\n    scDataQC, exprs_values = \"norm_exprs_rbe\", shape_by = \"c1_machine\", \n        colour_by = \"sample_type\", size_by = \"total_features\") + \n    ggtitle(\"PCA - removeBatchEffect normalisation\") + \n    theme(legend.position = \"bottom\")\nplt_rbe_norm\n```\n\nAfter normalisation with `removeBatchEffect`, the patient effect is still not the strongest one picked out by PCA. Nevertheless, there is now no correlation between PCs and C1 machine, as the plot below shows.\n\n```{r limma-remove-batch-pcs-corr, fig.height=7, fig.width=7}\nplotQC(scDataQC, type = \"find-pcs\", variable = \"c1_machine\", \n       exprs_values = \"norm_exprs_rbe\")\n```\n\n\nLook at the performance of the RUVs method:\n\n```{r ruv-seq-s, echo=TRUE, eval=TRUE, fig.height=14, fig.width=9}\n# One approach to finding and removing hidden, unwanted sources of variability is\n# the `RUVSeq` package.\n\nscDataRUV <- filter(scData, use)\nscDataRUV <- scDataRUV[fData(scData)$use | fData(scData)$is_feature_control,]\nscIdx <- matrix(-1, ncol = max(table(scDataRUV$sample_type)), nrow = 2)\nscIdx[1,] <- which(scDataRUV$sample_type == \"cell from patient B\")\ntmp <- which(scDataRUV$sample_type == \"cell from patient A\")\nscIdx[2, 1:length(tmp)] <- tmp\n# cIdx <- (fData(scDataRUV)$is_feature_control & fData(scDataRUV)$n_cells_exprs >= 10) \n## Running RUVs\ncIdx <- rownames(scDataRUV)\nruv_list <- list()\nfor (k in 1:9) {\n    ruvs <- RUVs(counts(scDataRUV), cIdx, k = k,\n                 scIdx = scIdx, isLog = FALSE)\n    norm_counts(scDataRUV) <- ruvs$normalizedCounts\n    exprs(scDataRUV) <- edgeR::cpm.default(norm_counts(scDataRUV), log = TRUE, \n                                           prior.count = scDataRUV@logExprsOffset)\n    plt_norm_ruv <- plotPCA(\n        scDataRUV, exprs_values = \"exprs\", shape_by = \"c1_machine\", \n        colour_by = \"sample_type\", size_by = \"total_features\", \n        scale_features = TRUE) + \n        ggtitle(paste(\"PCA - RUVs normalisation: k =\", k)) + \n        theme_bw(8)\n    ruv_list[[k]] <- plt_norm_ruv\n}\n\nfigplot_ruv <- cowplot::plot_grid(plotlist = ruv_list[1:8], labels = letters[1:8], ncol = 2)\nfigplot_ruv\nfigplot_ruv <- cowplot::plot_grid(plotlist = ruv_list, labels = letters[1:9])\ncowplot::save_plot(\"../figures/supplement/ruvs_figure.png\", figplot_ruv, \n                   ncol = 3, nrow = 3, base_height = 5, base_aspect_ratio = 0.9)\n```\n\n```{r ruv-seq-s-qc-plots, echo=TRUE, eval=TRUE, message=FALSE, results='hide'}\nplotQC(scDataRUV, type = \"explanatory-variables\")\nplotQC(scDataRUV, type = \"find-pcs\", variable = \"sample_type\")\n```\n\n```{r ruvseq-red-dim-k6}\nruvs <- RUVs(counts(scDataRUV), cIdx, k = 6, scIdx = scIdx, isLog = FALSE)\nreducedDimension(scDataRUV) <- ruvs$W\nplotReducedDim(scDataRUV, shape_by = \"c1_machine\", \n               colour_by = \"sample_type\", size_by = \"total_features\") + theme_bw()\n\n```\n\nLook at the performance of the RUVg method:\n\n```{r ruv-seq-g, echo=TRUE, eval=TRUE, fig.height=14, fig.width=9}\n# One approach to finding and removing hidden, unwanted sources of variability is\n# the `RUVSeq` package.\n## Running RUVs\ncIdx <- fData(scDataRUV)$is_feature_control\nruvg_list <- list()\nfor (k in 1:9) {\n    ruvs <- RUVg(counts(scDataRUV), cIdx, k = k, isLog = FALSE)\n    norm_counts(scDataRUV) <- ruvs$normalizedCounts\n    exprs(scDataRUV) <- edgeR::cpm.default(norm_counts(scDataRUV), log = TRUE, \n                                           prior.count = scDataRUV@logExprsOffset)\n    plt_norm_ruv <- plotPCA(\n        scDataRUV, exprs_values = \"exprs\", shape_by = \"c1_machine\", \n        colour_by = \"sample_type\", size_by = \"total_features\", \n        scale_features = TRUE) + \n        ggtitle(paste(\"PCA - RUVg normalisation: k =\", k)) + \n        theme_bw(8)\n    ruvg_list[[k]] <- plt_norm_ruv\n}\n\nfigplot_ruvg <- cowplot::plot_grid(plotlist = ruvg_list[1:8], labels = letters[1:8],\n                                   ncol = 2)\nfigplot_ruvg\nfigplot_ruvg <- cowplot::plot_grid(plotlist = ruvg_list, labels = letters[1:9])\ncowplot::save_plot(\"../figures/supplement/ruvg_figure.png\", figplot_ruv, \n                   ncol = 3, nrow = 3, base_height = 5, base_aspect_ratio = 0.9)\n\n```\n\n```{r ruv-g-qc-plots, message=FALSE, results='hide'}\nplotQC(scDataRUV, type = \"explanatory-variables\")\nplotQC(scDataRUV, type = \"find-pcs\", variable = \"sample_type\")\nscDataRUV$c1_machine <- as.factor(scDataRUV$c1_machine)\nplotQC(scDataRUV, type = \"find-pcs\", variable = \"c1_machine\")\n\n```\n\nUnfortunately, the RUVg method does not do a good job of removing the C1 machine effect. The machine used is still correlated with the first PC even after removing 9 hidden factors of unwanted variation.\n\n\nThus, after convenient pre-processing, QC and normalisation with \\scater, the data\nare well organised (with feature and cell metadata and many data transformations),\nclean and tidy, and are ready for further statistical modeling and analysis.\n\n---\n\n### 7. DOWNSTREAM ANALYSIS\n\nExpression data at a single-cell resolution not only allows testing for differential expression,  but exploring how this is dependent on sub-types of cells and/or how genes coexpress with each other across cells. As with normalisation,  single-cell analysis methodology is an area in its infancy and deserving of discussion that is beyond this case study. Here we simply demonstrate how QC'ed and normalised data contained within an SCESet object allows for easy downstream interrogation. Let's assume we are interested in defining differential expression as change in expression frequency. This can be done with a standard generalised linear model and the ```qvalue``` package to control false discovery rates. \n\\    \n\n```{r de-testing, echo=T, eval=T, message=F, warning=F, fig.align=\"center\"}\nlibrary( \"qvalue\" )\n\nsm <- scDataQC$sample_type # the two samples\nde <- data.frame( t( apply( norm_exprs(scDataQC) > 0, 1, # test change in expression frequency \n                            function( y ) coef(summary(glm(y ~ sm, family = \"binomial\" ) ) )[2, c(1,4)])),  check.names = FALSE)\nde$qvalue <- qvalue( de[, \"Pr(>|z|)\"], fdr.level = 0.05 )$qvalues # control for false disovery rate\nde <- de[order( de$qvalue, decreasing = FALSE ), ] # order by global statistical evidence\nknitr::kable(head( de ))\n```\n\nIn `scater` the `plotExpression` function enables the convenient visualisation of expression values for a set of features. Here, the expression values for the six most DE genes for expression frequency between patients are shown. The units for expression in the plot can be defined with the `exprs_values` argument (the expression values must exist with the provided name in the `assayData` slot of the SCESet object; if not the default `exprs` values will be used, with a warning). As with other plots in `scater` we can use phenotype data variables to define the colour and shapr of the points.\n\n```{r plot-exprs-de, echo=T, eval=T, message=F, warning=F, fig.align=\"center\", fig.width=9, fig.height=5}\nplotExpression(scDataQC, rownames(de)[1:6], x = \"sample_type\", ncol = 3)\nplotExpression(scDataQC, rownames(de)[1:6], ncol = 3, exprs_values = \"counts\",\n               x = \"sample_type\", colour_by = \"log10_counts_endogenous_features\")\nplotExpression(scDataQC, rownames(de)[1:6], exprs_values = \"norm_exprs\", \n               x = \"sample_type\", colour_by = \"total_features\", \n               shape_by = \"c1_machine\", ncol = 3)\n```\n\\  \n\nOne natural question is if differentially expressed genes are co-expressed. Clustering of the genes,  using Gaussian mixture models,  suggests that the immunoglobulin genes with  increased expression in patient B form a tight coexpression cluster (shown in red) that is distinct from the other differentially expressed genes.  \n\\  \n\n```{r, echo=T, eval=T, message=F, warning=F, fig.width=6, fig.height=12, fig.align=\"center\", cache=TRUE}\n\nlibrary( \"mclust\" )\n\ncoexprsA <- cor( t( norm_exprs(scDataQC)[row.names(de)[de$qvalue < 0.05], \n                              sm == \"cell from patient A\"] ),  # rank coexpression\n                 method = \"spearman\" )\ncoexprsA <- data.frame( cmdscale( (1 - coexprsA) / 2 ) ) # multidimensional scaling of the coexpression\nclustA <- Mclust( coexprsA, modelNames = \"VVV\" ) # model based clustering of the differentially expressed genes\n\ncoexprsB <- cor( t( norm_exprs(scDataQC)[row.names(de)[de$qvalue < 0.05], \n                                         sm == \"cell from patient B\"] ),  # repeat\n                method = \"spearman\" )\ncoexprsB <- data.frame( cmdscale( (1 - coexprsB) / 2 ) ) \nclustB <- Mclust( coexprsB, modelNames = \"VVV\" ) \n\ngns <- fData( scDataQC )[row.names( de )[de$qvalue < 0.05], \"hgnc_symbol\"] # differentially expressed genes' symbols\ncls <- c( \"firebrick\", \"grey30\" )[clustB$classification] # colour by clustering\neff <- rank( de$Estimate[de$qvalue < 0.05] ) / 60 # size by relative expression in patient B \n\npar( mfrow = c( 2, 1 ) )\nplot( clustA, what = \"density\", bty = \"n\", xlab = \"patient A dimension one\",  ylab = \"patient A dimension two\" )\ntext( coexprsA[, 1], coexprsA[, 2], gns, cex = eff, col = cls )\nplot( clustB, what = \"density\", bty = \"n\", xlab = \"patient B dimension one\",  ylab = \"patient B dimension two\" )\ntext( coexprsB[, 1], coexprsB[, 2], gns, cex = eff, col = cls )\n\n```\n\\  \n\n---\n\n### 8.  TECHNICAL STUFF\n\n\nScater has been tested on Mac OS X and Linux environments and requires the R packages:\n\n* Biobase\n* BiocGenerics\n* ggplot2\n* methods\n\nand imports the packages:\n\n* biomaRt\n* data.table\n* dplyr\n* edgeR\n* grid\n* limma\n* matrixStats\n* plyr\n* reshape2\n* rhdf5\n* rjson\n* viridis\n\nThis case study was run using the following platform and R package versions:  \n\\  \n\n```{r, echo=FALSE, eval=TRUE}\n\nsessionInfo()\n\n```\n\n\n```{r figures-for-paper, echo=TRUE, results='hide'}\n### Figures for the paper\nif ( requireNamespace(\"cowplot\") ) {\n    ## QC figure\n    scData$well_type <- \"single cell\"\n    scData$well_type[scData$sample_type == \"blank (empty site) control\"] <-\n        \"blank control\"\n    scData$well_type[scData$sample_type == \"bulk control from patient A\"] <-\n        \"bulk control\"\n    scData$well_type[scData$sample_type == \"bulk control from patient B\"] <-\n        \"bulk control\"\n    p1 <- plot( scData, colour_by = \"well_type\", exprs_values = \"counts\")\n    p2 <- plotPCA( scData, shape_by = \"sample_type\", \n                   pca_data_input = \"pdata\", detect_outliers = TRUE,\n                   selected_variables = c(\"cdna_recovered_in_ng_per_ul_no_miss\",\n                                          \"pct_counts_top_100_features\",\n                                          \"total_features\", \n                                          \"pct_counts_feature_controls\",\n                                          \"n_detected_feature_controls\", \n                                          \"log10_counts_endogenous_features\",\n                                          \"log10_counts_feature_controls\"))\n    p3 <- plotQC( scData[fData( scData )$use, pData( scData )$use], \n        type = \"highest-expression\", \n        col_by_variable = \"sample_type\" ) + coord_cartesian(xlim = c(0, 6))\n    p4 <- plotQC(scData, type = \"exprs\") \n    p5 <- plotQC( scData[fData( scData )$use, scData$use], \n        type = \"explanatory-variables\", \n        variables = c(\"pct_counts_top_100_features\", \"total_features\", \n                      \"c1_machine\",\n                      \"n_detected_feature_controls\", \n                      \"log10_counts_endogenous_features\",\n                      \"sample_type\") ) + \n        xlab(expression(paste(R ^ 2, \" (% variance explained; log10-scale)\"))) +\n    theme(legend.position = \"bottom\", legend.text = element_text(size = 7))\n    p6 <- plotQC( scData[fData( scData )$use, scData$use], \n        type = \"find-pcs\", variable = \"c1_machine\")\n    figplot1 <- cowplot::plot_grid(p1, p2, p3, p4, p5, p6, \n                                  labels = letters, ncol = 3,\n                                  label_size = 20)\n    cowplot::save_plot(\"../figures/figure3.pdf\", figplot1, ncol = 3, nrow = 2,\n                       base_height = 3.5, base_aspect_ratio = 1.4)\n    cowplot::save_plot(\"../figures/figure3.png\", figplot1, ncol = 3, nrow = 2,\n                       base_height = 3.5, base_aspect_ratio = 1.4)\n    cowplot::save_plot(\"../figures/figure3.jpg\", figplot1, ncol = 3, nrow = 2,\n                       base_height = 3.5, base_aspect_ratio = 1.4, dpi = 350)\n\n    \n    ## dimension reduction figure\n    ww <- which(featureNames(scDataQC) %in% rownames(de)[c(1:2, 5)])\n    # ww <- which(featureNames(scDataQC) %in% c(\"IGHM_ENSG00000211899\", \n    #                                           \"IGHV4-34_ENSG00000211956\",\n    #                                           \"CD86_ENSG00000114013\"))\n    # ww <- which(featureNames(scDataQC) %in% c(\"IGHM\", \n    #                                           \"IGHV4-34\",\n    #                                           \"CD86\"))\n    featureNames(scDataQC)[ww] <- as.character(fData(scDataQC)$hgnc_symbol[ww])\n    feats_to_plot <- as.character(fData(scDataQC)$hgnc_symbol[ww])\n    \n    p1 <- plotPCA(scData[, scData$use], size_by = \"total_features\", \n                  colour_by = \"sample_type\", theme_size = 14,\n                  shape_by = \"c1_machine\") + ggtitle(\"PCA - all genes\") + \n        ylab(\"Component 2\") +\n        theme(legend.position = \"bottom\", legend.text = element_text(size = 10), \n              legend.title = element_text(size = 11))\n    p2 <- plotTSNE(scData[, scData$use], size_by = \"total_features\", \n                   colour_by = \"sample_type\", theme_size = 14,\n                   shape_by = \"c1_machine\", rand_seed = 20151225) + \n        ggtitle(\"t-SNE - all genes\") + \n        theme(legend.position = \"bottom\", legend.text = element_text(size = 10),\n              legend.title = element_text(size = 11))\n    p3 <- plotDiffusionMap( scData[, scData$use], size_by = \"total_features\", \n                            colour_by = \"sample_type\", \n                            shape_by = \"c1_machine\", theme_size = 14) + \n        ggtitle(\"Diffusion map - all genes\") +\n        theme(legend.position = \"bottom\", legend.text = element_text(size = 10),\n              legend.title = element_text(size = 11))\n    p4 <- plotPCA(scData[, scData$use], feature_set = cell_cycle_genes, \n                  colour_by = featureNames(scData)[most_exprs_ccycle[7]], \n                  shape_by = \"sample_type\", theme_size = 14) + \n        ggtitle(\"PCA - cell cycle genes\") + ylab(\"Component 2\") +\n        geom_point(aes(colour = colour_by, shape = shape_by), alpha = 0.6, size = 4) +\n        theme(legend.position = \"bottom\", legend.text = element_text(size = 10),\n              legend.title = element_text(size = 11))\n    p5 <- plotTSNE(scData[, scData$use], feature_set = cell_cycle_genes, \n                   colour_by = featureNames(scData)[most_exprs_ccycle[7]], \n                   shape_by = \"sample_type\", rand_seed = 20151225, theme_size = 14) + \n        geom_point(aes(colour = colour_by, shape = shape_by), alpha = 0.6, size = 4) +\n        ggtitle(\"t-SNE - cell cycle genes\") + \n        theme(legend.position = \"bottom\", legend.text = element_text(size = 10),\n              legend.title = element_text(size = 11))\n    p6 <- plotDiffusionMap( scData[, scData$use], feature_set = cell_cycle_genes, \n                            colour_by = featureNames(scData)[most_exprs_ccycle[7]], \n                            shape_by = \"sample_type\", theme_size = 14) + \n        geom_point(aes(colour = colour_by, shape = shape_by), alpha = 0.6, size = 4) +\n        ggtitle(\"Diffusion map - cell cycle genes\") +\n        theme(legend.position = \"bottom\", legend.text = element_text(size = 10),\n              legend.title = element_text(size = 11))\n    \n    plt_exprs <- plotExpression(\n        scDataQC, feats_to_plot, exprs_values = \"norm_exprs\", \n        x = \"sample_type\", colour_by = \"total_features\", ncol = 3, size = 4,\n        theme_size = 14) + ylab(\"Expression\") + xlab(NULL) +\n        theme(legend.text = element_text(size = 10),\n              legend.title = element_text(size = 11))\n    \n    figplot2 <- cowplot::ggdraw() +\n        cowplot::draw_plot(p1, 0, .62, 0.33, .38) +\n        cowplot::draw_plot_label(letters[1], x = 0, y = 1, size = 24) +\n        cowplot::draw_plot(p2, 0.33, .62, 0.33, .38) +\n        cowplot::draw_plot_label(letters[2], x = 0.33, y = 1, size = 24) +\n        cowplot::draw_plot(p3, 0.66, .62, 0.33, .38) +\n        cowplot::draw_plot_label(letters[3], x = 0.66, y = 1, size = 24) +\n        cowplot::draw_plot(p4, 0, .27, 0.33, .35) +\n        cowplot::draw_plot_label(letters[4], x = 0, y = 0.65, size = 24) +\n        cowplot::draw_plot(p5, 0.33, .27, 0.33, .35) +\n        cowplot::draw_plot_label(letters[5], x = 0.33, y = 0.65, size = 24) +\n        cowplot::draw_plot(p6, 0.66, .27, 0.33, .35) +\n        cowplot::draw_plot_label(letters[6], x = 0.66, y = 0.65, size = 24) +\n        cowplot::draw_plot(plt_exprs, 0, 0, 1, 0.27) +\n        cowplot::draw_plot_label(letters[7],  x = 0, y = 0.3, size = 24)\n    figplot2\n    \n    cowplot::save_plot(\"../figures/figure4.pdf\", figplot2, nrow = 3, ncol = 3,\n                       base_height = 3.5, base_aspect_ratio = 1.2)\n    cowplot::save_plot(\"../figures/figure4.png\", figplot2,  ncol = 3, nrow = 3,\n                       base_height = 3.5, base_aspect_ratio = 1.2)\n    cowplot::save_plot(\"../figures/figure4.jpg\", figplot2,  ncol = 3, nrow = 3,\n                       base_height = 3.5, base_aspect_ratio = 1.2, dpi = 350)\n    \n    if ( requireNamespace(\"RUVSeq\")) {\n        library( \"RUVSeq\" )\n        scDataRUV <- filter(scData, use)\n        scDataRUV <- scDataRUV[fData(scData)$use | fData(scData)$is_feature_control,]\n        scIdx <- matrix(-1, ncol = max(table(scDataRUV$sample_type)), nrow = 2)\n        scIdx[1,] <- which(scDataRUV$sample_type == \"cell from patient B\")\n        tmp <- which(scDataRUV$sample_type == \"cell from patient A\")\n        scIdx[2, 1:length(tmp)] <- tmp\n        cIdx <- featureNames(scDataRUV)\n        ## RUVs\n        ruvs <- RUVs(counts(scDataRUV), cIdx, k = 1, scIdx = scIdx, isLog = FALSE)\n        norm_counts(scDataRUV) <- ruvs$normalizedCounts\n        exprs(scDataRUV) <- edgeR::cpm.default(norm_counts(scDataRUV), log = TRUE, \n                                               prior.count = scDataRUV@logExprsOffset)\n        plt_norm_ruvs <- plotPCA(\n            scDataRUV, exprs_values = \"exprs\", shape_by = \"c1_machine\", \n            colour_by = \"sample_type\", size_by = \"total_features\", \n            scale_features = TRUE) + \n            ggtitle(paste(\"PCA - RUVs normalisation: k =\", 1)) +\n            theme(legend.position = \"bottom\")\n        \n        ## RUVg\n        cIdx <- (fData(scDataRUV)$is_feature_control & fData(scDataRUV)$n_cells_exprs >= 10)\n        ruvg <- RUVg(counts(scDataRUV), cIdx, k = 1, isLog = FALSE)\n        norm_counts(scDataRUV) <- ruvs$normalizedCounts\n        exprs(scDataRUV) <- edgeR::cpm.default(norm_counts(scDataRUV), log = TRUE, \n                                               prior.count = scDataRUV@logExprsOffset)\n        plt_norm_ruvg <- plotPCA(\n            scDataRUV, exprs_values = \"exprs\", shape_by = \"c1_machine\", \n            colour_by = \"sample_type\", size_by = \"total_features\", \n            scale_features = TRUE) + \n            ggtitle(paste(\"PCA - RUVg normalisation: k =\", 1)) +\n            theme(legend.position = \"bottom\")\n\n        plt_pca_endog_norm <- plt_pca_endog_norm + \n            theme(legend.position = \"none\")\n\n        plt_sf_norm_resid <- plt_sf_norm_resid + \n            theme(legend.position = \"none\")\n    \n\n        figplot3 <- cowplot::plot_grid(plt_pca_endog_norm, plt_sf_norm_resid,\n                                       plt_norm_ruvs,\n                                       labels = letters, ncol = 1,\n                                       rel_heights = c(0.75, 0.75, 1), label_size = 18)\n        cowplot::save_plot(\"../figures/figure5.pdf\", figplot3, ncol = 1, nrow = 3,\n                           base_height = 3.5, base_aspect_ratio = 1.2)\n        cowplot::save_plot(\"../figures/figure5.png\", figplot3, ncol = 1, nrow = 3,\n                           base_height = 3.5, base_aspect_ratio = 1.2)\n        cowplot::save_plot(\"../figures/figure5.jpg\", figplot3, ncol = 1, nrow = 3,\n                           base_height = 3.5, base_aspect_ratio = 1.2, dpi = 350)\n\n    \n    }\n    \n    \n}\n\n```\n",
    "created" : 1463068485538.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1000200888",
    "id" : "C852CEC3",
    "lastKnownWriteTime" : 1471020282,
    "last_content_update" : 1471020282539,
    "path" : "~/Google Drive/Manuscripts/scater_paper_nov-2015/scater_case_study/case_study.Rmd",
    "project_path" : "case_study.Rmd",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}